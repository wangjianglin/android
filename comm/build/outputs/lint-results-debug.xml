<?xml version="1.0" encoding="UTF-8"?>
<issues format="4" by="lint 25.2.5">

    <issue
        id="NewApi"
        severity="Error"
        message="Multi-catch with these reflection exceptions requires API level 19 (current min is 15) because they get compiled to the common but new super type `ReflectiveOperationException`. As a workaround either create individual catch statements, or catch `Exception`."
        category="Correctness"
        priority="6"
        summary="Calling new methods on older versions"
        explanation="This check scans through all the Android API calls in the application and warns about any calls that are not available on *all* versions targeted by this application (according to its minimum SDK attribute in the manifest).

If you really want to use this API and don&apos;t need to support older devices just set the `minSdkVersion` in your `build.gradle` or `AndroidManifest.xml` files.

If your code is *deliberately* accessing newer APIs, and you have ensured (e.g. with conditional execution) that this code will only ever be called on a supported platform, then you can annotate your class or method with the `@TargetApi` annotation specifying the local minimum SDK to apply, such as `@TargetApi(11)`, such that this check considers 11 rather than your manifest file&apos;s minimum SDK as the required API level.

If you are deliberately setting `android:` attributes in style definitions, make sure you place this in a `values-vNN` folder in order to avoid running into runtime conflicts on certain devices where manufacturers have added custom attributes whose ids conflict with the new ones on later platforms.

Similarly, you can use tools:targetApi=&quot;11&quot; in an XML file to indicate that the element will only be inflated in an adequate context."
        errorLine1="        } catch (InstantiationException | IllegalAccessException e) {"
        errorLine2="                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
        quickfix="studio,adt">
        <location
            file="/lin/code/lib/android/comm/src/main/java/lin/comm/tcp/CommunicateRecv.java"
            line="43"
            column="18"/>
    </issue>

    <issue
        id="NewApi"
        severity="Error"
        message="Multi-catch with these reflection exceptions requires API level 19 (current min is 15) because they get compiled to the common but new super type `ReflectiveOperationException`. As a workaround either create individual catch statements, or catch `Exception`."
        category="Correctness"
        priority="6"
        summary="Calling new methods on older versions"
        explanation="This check scans through all the Android API calls in the application and warns about any calls that are not available on *all* versions targeted by this application (according to its minimum SDK attribute in the manifest).

If you really want to use this API and don&apos;t need to support older devices just set the `minSdkVersion` in your `build.gradle` or `AndroidManifest.xml` files.

If your code is *deliberately* accessing newer APIs, and you have ensured (e.g. with conditional execution) that this code will only ever be called on a supported platform, then you can annotate your class or method with the `@TargetApi` annotation specifying the local minimum SDK to apply, such as `@TargetApi(11)`, such that this check considers 11 rather than your manifest file&apos;s minimum SDK as the required API level.

If you are deliberately setting `android:` attributes in style definitions, make sure you place this in a `values-vNN` folder in order to avoid running into runtime conflicts on certain devices where manufacturers have added custom attributes whose ids conflict with the new ones on later platforms.

Similarly, you can use tools:targetApi=&quot;11&quot; in an XML file to indicate that the element will only be inflated in an adequate context."
        errorLine1="            e.printStackTrace();"
        errorLine2="              ~~~~~~~~~~~~~~~"
        quickfix="studio,adt">
        <location
            file="/lin/code/lib/android/comm/src/main/java/lin/comm/tcp/CommunicateRecv.java"
            line="44"
            column="15"/>
    </issue>

    <issue
        id="Recycle"
        severity="Warning"
        message="This `Cursor` should be freed up after use with `#close()`"
        category="Performance"
        priority="7"
        summary="Missing `recycle()` calls"
        explanation="Many resources, such as TypedArrays, VelocityTrackers, etc., should be recycled (with a `recycle()` call) after use. This lint check looks for missing `recycle()` calls."
        errorLine1="            Cursor c = this.getWritableDatabase().rawQuery(&quot;SELECT sum(&quot; + KEY_FILE_SIZE + &quot;) FROM &quot; + DATABASE_TABLE, null);"
        errorLine2="                                                  ~~~~~~~~">
        <location
            file="/lin/code/lib/android/comm/src/main/java/lin/comm/http/CacheDownloadFile.java"
            line="143"
            column="51"/>
    </issue>

    <issue
        id="StaticFieldLeak"
        severity="Warning"
        message="Do not place Android context classes in static fields (static reference to `HttpCommunicate` which has field `context` pointing to `Context`); this is a memory leak (and also breaks Instant Run)"
        category="Performance"
        priority="6"
        summary="Static Field Leaks"
        explanation="A static field will leak contexts."
        errorLine1=" private static HttpCommunicate _tmp = new HttpCommunicate();"
        errorLine2=" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="/lin/code/lib/android/comm/src/main/java/lin/comm/http/HttpCommunicate.java"
            line="63"
            column="2"/>
    </issue>

    <issue
        id="StaticFieldLeak"
        severity="Warning"
        message="Do not place Android context classes in static fields; this is a memory leak (and also breaks Instant Run)"
        category="Performance"
        priority="6"
        summary="Static Field Leaks"
        explanation="A static field will leak contexts."
        errorLine1=" private static Context context;"
        errorLine2=" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="/lin/code/lib/android/comm/src/main/java/lin/comm/http/HttpCommunicate.java"
            line="359"
            column="2"/>
    </issue>

    <issue
        id="UseSparseArrays"
        severity="Warning"
        message="Use `new SparseArray&lt;Class>(...)` instead for better performance"
        category="Performance"
        priority="4"
        summary="HashMap can be replaced with SparseArray"
        explanation="For maps where the keys are of type integer, it&apos;s typically more efficient to use the Android `SparseArray` API. This check identifies scenarios where you might want to consider using `SparseArray` instead of `HashMap` for better performance.

This is *particularly* useful when the value types are primitives like ints, where you can use `SparseIntArray` and avoid auto-boxing the values from `int` to `Integer`.

If you need to construct a `HashMap` because you need to call an API outside of your control which requires a `Map`, you can suppress this warning using for example the `@SuppressLint` annotation."
        errorLine1="    private static Map&lt;Byte, Class&lt;?>> protocolParsers = new HashMap&lt;Byte, Class&lt;?>>();"
        errorLine2="                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="/lin/code/lib/android/comm/src/main/java/lin/comm/tcp/CommunicateRecv.java"
            line="14"
            column="58"/>
    </issue>

    <issue
        id="UseSparseArrays"
        severity="Warning"
        message="Use `new SparseArray&lt;ProtocolParser>(...)` instead for better performance"
        category="Performance"
        priority="4"
        summary="HashMap can be replaced with SparseArray"
        explanation="For maps where the keys are of type integer, it&apos;s typically more efficient to use the Android `SparseArray` API. This check identifies scenarios where you might want to consider using `SparseArray` instead of `HashMap` for better performance.

This is *particularly* useful when the value types are primitives like ints, where you can use `SparseIntArray` and avoid auto-boxing the values from `int` to `Integer`.

If you need to construct a `HashMap` because you need to call an API outside of your control which requires a `Map`, you can suppress this warning using for example the `@SuppressLint` annotation."
        errorLine1="    private Map&lt;Byte, ProtocolParser> protocolParserInts = new HashMap&lt;Byte, ProtocolParser>();"
        errorLine2="                                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="/lin/code/lib/android/comm/src/main/java/lin/comm/tcp/CommunicateRecv.java"
            line="33"
            column="60"/>
    </issue>

</issues>
